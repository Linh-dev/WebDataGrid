<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Combination_Gauge_Header" xml:space="preserve">
    <value>Gauge Layers</value>
  </data>
  <data name="Combination_Gauge_Description_1" xml:space="preserve">
    <value>This sample demonstrates using the WebGauge's composition model to construct advanced Gauge displays.</value>
  </data>
  <data name="Combination_Gauge_Description_2" xml:space="preserve">
    <value>Try this: Use the checkboxes below to toggle the visibility of individual Gauge Layers.</value>
  </data>
  <data name="Combination_Gauge_Description_3" xml:space="preserve">
    <value>Visible Layers</value>
  </data>
  <data name="Combination_Gauge_Type_1" xml:space="preserve">
    <value>Radial</value>
  </data>
  <data name="Combination_Gauge_Type_2" xml:space="preserve">
    <value>Linear</value>
  </data>
  <data name="Combination_Gauge_Type_3" xml:space="preserve">
    <value>Digital</value>
  </data>
  <data name="Mouse_Interaction_Header" xml:space="preserve">
    <value>Mouse Interaction</value>
  </data>
  <data name="Mouse_Interaction_Description_1" xml:space="preserve">
    <value>This sample demonstrates using the WebGauge's built in AJAX features to provide a rich User Interaction.</value>
  </data>
  <data name="Mouse_Interaction_Description_2" xml:space="preserve">
    <value>Try this: Click on a point on the gauge to set the needle position.</value>
  </data>
  <data name="Clock_Description" xml:space="preserve">
    <value>This sample demonstrates the built-in asynchronous functionality of the WebGauge.  By setting the RefreshInterval property of the gauge, you can set it up to automatically refresh itself based on a timed interval.  In this example, you can use the dropdown to control the size of the refresh interval.  You can also use the Refresh NOW button which leverages the ClientSide Object Model of the Gauge, calling "oWebGauge.Refresh()"</value>
  </data>
  <data name="Clock_Header" xml:space="preserve">
    <value>A Refreshing Clock</value>
  </data>
  <data name="Clock_Label1" xml:space="preserve">
    <value>Refresh Every:</value>
  </data>
  <data name="Clock_Label2" xml:space="preserve">
    <value>second(s).</value>
  </data>
  <data name="Clock_Label3" xml:space="preserve">
    <value>Refresh NOW</value>
  </data>
  <data name="GaugeImagePipeUrl" xml:space="preserve">
    <value>/samplesbrowser/Samples/WebGauge/Display/101Presets/GaugeImagePipe.aspx</value>
  </data>
  <data name="Presets_Description1" xml:space="preserve">
    <value>This sample demonstrates how to leverage the power of reusable WebGauge Preset
			 files. Included with Infragistics are over 100 professionally designed WebGauges to choose from.  Click on a thumbnail on the left to view the full sized gauge. Click on the View XML button to view the preset file used to create the gauge that is displayed.</value>
  </data>
  <data name="Presets_Description2" xml:space="preserve">
    <value>Output Caching</value>
  </data>
  <data name="Presets_Description3" xml:space="preserve">
    <value>The thumnails in this example are set up as static images, however there is code included to show how you can generate the thumbnails dynamically.  Because generating over 100 live controls can be a time consuming process the user control can be configured to use OutputCaching. By enabling OutputCaching on the UserControl, you can employ a 'partial cache' technique for the page ensuring that content outside of the usercontrol is not cached.</value>
  </data>
  <data name="Presets_Header" xml:space="preserve">
    <value>WebGauge - Presets 101</value>
  </data>
  <data name="Presets_ViewXML" xml:space="preserve">
    <value>View XML</value>
  </data>
  <data name="Ranges_Description1" xml:space="preserve">
    <value>Use the options below to customize the Radial Gauge, and test how ranges effect the visual appearance of the gauge.</value>
  </data>
  <data name="Ranges_Description2" xml:space="preserve">
    <value>Try this</value>
  </data>
  <data name="Ranges_Description3" xml:space="preserve">
    <value>Set the StartValue to 0</value>
  </data>
  <data name="Ranges_Description4" xml:space="preserve">
    <value>Set the EndValue to 5</value>
  </data>
  <data name="Ranges_Description5" xml:space="preserve">
    <value>Click Submit Changes to see the new Range.</value>
  </data>
  <data name="Ranges_Header" xml:space="preserve">
    <value>Radial Gauge Ranges</value>
  </data>
  <data name="Ranges_Label1" xml:space="preserve">
    <value>Select a Range:</value>
  </data>
  <data name="Ranges_Label10" xml:space="preserve">
    <value>Submit Changes</value>
  </data>
  <data name="Ranges_Label2" xml:space="preserve">
    <value>green</value>
  </data>
  <data name="Ranges_Label3" xml:space="preserve">
    <value>orange</value>
  </data>
  <data name="Ranges_Label4" xml:space="preserve">
    <value>red</value>
  </data>
  <data name="Ranges_Label5" xml:space="preserve">
    <value>StartValue:</value>
  </data>
  <data name="Ranges_Label6" xml:space="preserve">
    <value>EndValue:</value>
  </data>
  <data name="Ranges_Label7" xml:space="preserve">
    <value>InnerExtentStart:</value>
  </data>
  <data name="Ranges_Label8" xml:space="preserve">
    <value>InnerExtentEnd:</value>
  </data>
  <data name="Ranges_Label9" xml:space="preserve">
    <value>OuterExtent:</value>
  </data>
</root>